<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>BreadScan v5 â€” Porosity Analyzer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#0f0e0b;--s1:#1a1813;--s2:#221f18;--s3:#2d2820;
  --border:#3a3428;--gold:#c9a84c;--gold2:#e8c97a;
  --amber:#d4824a;--muted:#7a7060;--text:#e8dfc8;
  --green:#7ab87a;--red:#c97a6a;--blue:#7a9ab8;--r:4px;
}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
body{font-family:'DM Mono',monospace;background:var(--bg);color:var(--text);min-height:100vh}
body::before{content:'';position:fixed;inset:0;pointer-events:none;z-index:9999;opacity:.35;
  background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='.04'/%3E%3C/svg%3E")}

header{border-bottom:1px solid var(--border);padding:1.2rem 2.5rem;display:flex;align-items:baseline;gap:1.5rem;flex-wrap:wrap}
.logo{font-family:'Playfair Display',serif;font-size:1.4rem;font-weight:900;color:var(--gold)}
.logo-sub{font-size:.6rem;color:var(--muted);letter-spacing:.18em;text-transform:uppercase}
.logo-ref{margin-left:auto;font-size:.55rem;color:var(--muted);line-height:1.5;text-align:right}
.logo-ref span{color:var(--gold2)}

.layout{display:grid;grid-template-columns:285px 1fr;height:calc(100vh - 62px)}
.sidebar{border-right:1px solid var(--border);padding:1.5rem 1.2rem;display:flex;flex-direction:column;gap:1.3rem;background:var(--s1);overflow-y:auto}
.slabel{font-size:.57rem;letter-spacing:.2em;text-transform:uppercase;color:var(--muted);margin-bottom:.4rem}

.upload-zone{border:1px dashed var(--border);border-radius:var(--r);padding:1.1rem 1rem;text-align:center;cursor:pointer;transition:border-color .2s,background .2s;position:relative}
.upload-zone:hover,.upload-zone.drag{border-color:var(--gold);background:rgba(201,168,76,.04)}
.upload-zone input{position:absolute;inset:0;opacity:0;cursor:pointer}
.upload-icon{font-size:1.4rem;display:block;margin-bottom:.25rem}
.upload-zone p{font-size:.63rem;color:var(--muted);line-height:1.5}
.upload-zone strong{color:var(--gold2)}

.type-row{display:grid;grid-template-columns:1fr 1fr;gap:.4rem}
.tbtn{padding:.5rem;border:1px solid var(--border);background:var(--s2);color:var(--muted);font-family:'DM Mono',monospace;font-size:.62rem;border-radius:var(--r);cursor:pointer;text-align:center;transition:all .15s;line-height:1.4}
.tbtn:hover{border-color:var(--gold);color:var(--text)}
.tbtn.on{border-color:var(--gold);background:rgba(201,168,76,.1);color:var(--gold2)}
.tbtn .ic{font-size:.9rem;display:block;margin-bottom:.15rem}

.algo-badge{font-size:.58rem;background:var(--s3);border:1px solid var(--border);border-radius:var(--r);padding:.4rem .6rem;color:var(--blue);line-height:1.5}
.algo-badge strong{color:var(--gold2);display:block;margin-bottom:.15rem}

.cg{display:flex;flex-direction:column;gap:.3rem}
.cr{display:flex;justify-content:space-between;align-items:center;font-size:.64rem}
.cr span{color:var(--muted)}.cv{color:var(--gold2);min-width:3rem;text-align:right}
input[type=range]{-webkit-appearance:none;width:100%;height:2px;background:var(--border);border-radius:2px;outline:none}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:var(--gold);cursor:pointer;border:2px solid var(--bg)}

.ibox{background:rgba(201,168,76,.04);border:1px solid rgba(201,168,76,.13);border-radius:var(--r);padding:.55rem;font-size:.61rem;color:var(--muted);line-height:1.6}
.ibox strong{color:var(--gold2)}
.ibox.warn{background:rgba(212,130,74,.05);border-color:rgba(212,130,74,.2)}
.ibox.warn strong{color:var(--amber)}
.ibox.lit{background:rgba(122,154,184,.04);border-color:rgba(122,154,184,.2)}
.ibox.lit strong{color:var(--blue)}

hr.div{border:none;border-top:1px solid var(--border)}

.btn{width:100%;padding:.72rem;background:var(--gold);color:var(--bg);border:none;border-radius:var(--r);font-family:'DM Mono',monospace;font-size:.7rem;font-weight:500;letter-spacing:.1em;text-transform:uppercase;cursor:pointer;transition:background .15s,transform .1s;margin-top:auto}
.btn:hover{background:var(--gold2)}.btn:active{transform:scale(.98)}
.btn:disabled{background:var(--border);color:var(--muted);cursor:not-allowed}

/* MAIN */
.main{padding:1.5rem 2rem;display:flex;flex-direction:column;gap:1.5rem;overflow-y:auto;min-height:0}
.main>*{flex-shrink:0}

/* Metrics */
.metrics{display:grid;grid-template-columns:repeat(6,1fr);gap:1px;background:var(--border);border:1px solid var(--border);border-radius:var(--r);overflow:hidden}
.mc{background:var(--s1);padding:.8rem .9rem}.mc.empty .mv{color:var(--border)}
.ml{font-size:.53rem;letter-spacing:.1em;text-transform:uppercase;color:var(--muted);margin-bottom:.25rem}
.mv{font-family:'Playfair Display',serif;font-size:1.35rem;font-weight:700;color:var(--gold2);line-height:1}
.mu{font-size:.5rem;color:var(--muted);margin-top:.2rem}
.mv.hi{color:var(--green)}.mv.lo{color:var(--amber)}.mv.ok{color:var(--green)}

/* Canvases */
.cgrid{display:grid;grid-template-columns:repeat(5,1fr);gap:.65rem}
.cw{display:flex;flex-direction:column;gap:.35rem}
.clabel{font-size:.56rem;letter-spacing:.08em;text-transform:uppercase;color:var(--muted);display:flex;align-items:center;gap:.3rem}
.clabel::before{content:'';display:inline-block;width:5px;height:5px;border-radius:50%;background:var(--gold)}
.clabel .ref{font-size:.48rem;color:var(--muted);opacity:.6;margin-left:auto}
canvas{width:100%;aspect-ratio:1;object-fit:cover;border:1px solid var(--border);border-radius:var(--r);background:var(--s1);display:block;image-rendering:pixelated}
.ph{width:100%;aspect-ratio:1;border:1px dashed var(--border);border-radius:var(--r);display:flex;align-items:center;justify-content:center;color:var(--border);font-size:.53rem;letter-spacing:.06em;text-transform:uppercase}

/* Fingerprint */
.fp-wrap{border:1px solid var(--border);border-radius:var(--r);background:var(--s1);overflow:hidden}
.fp-head{padding:.7rem 1rem;border-bottom:1px solid var(--border);display:flex;align-items:baseline;gap:.75rem}
.fp-title{font-size:.58rem;letter-spacing:.14em;text-transform:uppercase;color:var(--muted)}
.fp-ref{font-size:.52rem;color:var(--blue)}
.fp-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:1px;background:var(--border)}
.fp-cell{background:var(--s2);padding:.65rem .85rem}
.fp-param{font-size:.55rem;color:var(--muted);margin-bottom:.2rem;letter-spacing:.06em;text-transform:uppercase}
.fp-val{font-family:'Playfair Display',serif;font-size:1.1rem;color:var(--gold2)}
.fp-unit{font-size:.5rem;color:var(--muted);margin-top:.1rem}
.fp-bar{height:2px;background:var(--border);border-radius:1px;margin-top:.4rem;overflow:hidden}
.fp-fill{height:100%;background:var(--gold);border-radius:1px;transition:width .4s ease}

/* Hist */
.hist-wrap{border:1px solid var(--border);border-radius:var(--r);padding:.9rem 1rem;background:var(--s1)}
.hist-title{font-size:.57rem;letter-spacing:.13em;text-transform:uppercase;color:var(--muted);margin-bottom:.8rem;display:flex;align-items:center;gap:.5rem}
.hist-bars{display:flex;align-items:flex-end;gap:3px;height:65px}
.bg2{flex:1;display:flex;flex-direction:column;align-items:center;gap:3px}
.bar{width:100%;border-radius:2px 2px 0 0;min-height:2px}
.btick{font-size:.48rem;color:var(--muted);text-align:center;margin-top:1px}
.pcats{display:grid;grid-template-columns:repeat(5,1fr);gap:.35rem;margin-top:.6rem}
.pcat{background:var(--s2);border:1px solid var(--border);border-radius:var(--r);padding:.4rem;text-align:center}
.pcat-l{font-size:.5rem;color:var(--muted);line-height:1.3}
.pcat-v{font-size:.78rem;color:var(--gold2);margin-top:.12rem}
.pcat-pct{font-size:.47rem;color:var(--muted)}

/* Log */
.log{font-size:.59rem;color:var(--muted);background:var(--s2);border:1px solid var(--border);border-radius:var(--r);padding:.7rem;white-space:pre-wrap;line-height:1.75;max-height:200px;overflow-y:auto}
.ok{color:var(--green)}.warn{color:var(--amber)}.lit{color:var(--blue)}

::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{background:var(--bg)}::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
/* Modal overlay */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.75);z-index:10000;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(4px)}
.modal-box{background:var(--s1);border:1px solid var(--border);border-radius:8px;padding:2rem 2.2rem;max-width:420px;width:90%;text-align:center}
.modal-box h2{font-family:'Playfair Display',serif;font-size:1.3rem;color:var(--gold2);margin-bottom:.3rem}
.modal-box p{font-size:.62rem;color:var(--muted);margin-bottom:1.4rem;line-height:1.6}
.modal-choices{display:flex;flex-direction:column;gap:.55rem}
.mbtn{padding:.75rem 1rem;border:1px solid var(--border);background:var(--s2);color:var(--text);font-family:'DM Mono',monospace;font-size:.65rem;border-radius:var(--r);cursor:pointer;transition:all .15s;text-align:left;line-height:1.5;display:flex;align-items:center;gap:.7rem}
.mbtn:hover{border-color:var(--gold);background:rgba(201,168,76,.06)}
.mbtn .mbtn-icon{font-size:1.1rem;flex-shrink:0}
.mbtn .mbtn-label{color:var(--gold2);font-weight:500}
.mbtn .mbtn-desc{color:var(--muted);font-size:.55rem}

/* Canvas overlay container */
.canvas-overlay-container{position:relative;display:inline-block;width:100%}
.canvas-overlay-container canvas{width:100%;display:block}
#cROI{position:absolute;inset:0;width:100%;height:100%;touch-action:none;background:transparent!important;cursor:crosshair;z-index:2}

/* Calibration modal */
.cal-modal-box{background:var(--s1);border:1px solid var(--border);border-radius:8px;padding:1.5rem;max-width:700px;width:95%;display:flex;flex-direction:column;gap:1rem}
.cal-modal-header{display:flex;align-items:baseline;justify-content:space-between;gap:1rem}
.cal-modal-header h2{font-family:'Playfair Display',serif;font-size:1.1rem;color:var(--gold2);white-space:nowrap}
.cal-modal-header .cal-steps{font-size:.58rem;color:var(--muted);line-height:1.5;text-align:right}
.cal-modal-header .cal-steps strong{color:var(--gold2)}
.cal-canvas-wrap{position:relative;width:100%;border:1px solid var(--border);border-radius:var(--r);overflow:hidden;background:var(--bg)}
.cal-canvas-wrap canvas{width:100%;display:block}
#cCalOverlay{position:absolute;inset:0;width:100%;height:100%;touch-action:none;background:transparent!important;cursor:crosshair}
.cal-controls{display:flex;align-items:center;gap:.7rem;flex-wrap:wrap}
.cal-input-row{display:flex;align-items:center;gap:.5rem}
.cal-input-row label{font-size:.57rem;color:var(--muted);white-space:nowrap}
.cal-input-row input,.cal-input-row select{background:var(--s2);border:1px solid var(--border);color:var(--text);font-family:'DM Mono',monospace;font-size:.62rem;padding:.35rem .5rem;border-radius:var(--r)}
.cal-input-row input{width:80px}
.cal-input-row select{width:auto}
.cal-input-row input:focus,.cal-input-row select:focus{outline:none;border-color:var(--gold)}
.cal-result{font-size:.62rem;color:var(--green);line-height:1.5;flex:1}
.cal-result strong{color:var(--green)}
.cal-confirm{padding:.55rem 1.4rem;background:var(--gold);color:var(--bg);border:none;border-radius:var(--r);font-family:'DM Mono',monospace;font-size:.62rem;font-weight:500;letter-spacing:.1em;text-transform:uppercase;cursor:pointer;transition:background .15s;margin-left:auto}
.cal-confirm:hover{background:var(--gold2)}
.cal-confirm:disabled{background:var(--border);color:var(--muted);cursor:not-allowed}
.cal-hint{font-size:.55rem;color:var(--muted);text-align:center;padding:.3rem;line-height:1.5}
.cal-hint strong{color:var(--gold2)}

/* ROI sidebar section */
.roi-section{display:none}
.roi-section.visible{display:block}
.roi-toggle{display:flex;gap:.4rem;margin-bottom:.5rem}
.roi-toggle .mbtn{flex:1;text-align:center;padding:.45rem;font-size:.58rem;justify-content:center}
.roi-toggle .mbtn.on{border-color:var(--gold);background:rgba(201,168,76,.1);color:var(--gold2)}
.roi-status{font-size:.56rem;color:var(--muted);line-height:1.5}
.roi-status strong{color:var(--gold2)}
.cal-badge{font-size:.56rem;background:var(--s3);border:1px solid rgba(122,184,122,.2);border-radius:var(--r);padding:.4rem .6rem;color:var(--green);line-height:1.5;margin-bottom:.5rem}
.cal-badge strong{color:var(--green)}

/* Interactive canvas column - wider on mobile */
@media(max-width:900px){.layout{grid-template-columns:1fr}.sidebar{border-right:none;border-bottom:1px solid var(--border)}.cgrid{grid-template-columns:repeat(3,1fr)}.cw-interactive{grid-column:1/-1}.metrics{grid-template-columns:repeat(3,1fr)}.fp-grid{grid-template-columns:repeat(2,1fr)}}
</style>
</head>
<body>

<!-- Upload mode modal -->
<div class="modal-overlay" id="uploadModal" style="display:none">
  <div class="modal-box">
    <h2>What's in your photo?</h2>
    <p>Choose how to calibrate for accurate measurements</p>
    <div class="modal-choices">
      <button class="mbtn" onclick="chooseMode('crumb')">
        <span class="mbtn-icon">ğŸ</span>
        <div><span class="mbtn-label">Crumb only</span><br><span class="mbtn-desc">No ruler or coin â€” analyze directly (pxÂ² units)</span></div>
      </button>
      <button class="mbtn" onclick="chooseMode('ruler')">
        <span class="mbtn-icon">ğŸ“</span>
        <div><span class="mbtn-label">Calibrate with ruler</span><br><span class="mbtn-desc">Touch 2 points on the ruler in next screen</span></div>
      </button>
      <button class="mbtn" onclick="chooseMode('coin')">
        <span class="mbtn-icon">ğŸª™</span>
        <div><span class="mbtn-label">Calibrate with coin</span><br><span class="mbtn-desc">Touch 2 edges of the coin in next screen</span></div>
      </button>
    </div>
  </div>
</div>

<!-- Calibration modal â€” large image for touching points -->
<div class="modal-overlay" id="calModal" style="display:none">
  <div class="cal-modal-box">
    <div class="cal-modal-header">
      <h2 id="calModalTitle">Calibrate with ruler</h2>
      <div class="cal-steps" id="calSteps"><strong>Step 1:</strong> Touch the first point</div>
    </div>
    <div class="cal-canvas-wrap">
      <canvas id="cCalImg"></canvas>
      <canvas id="cCalOverlay"></canvas>
    </div>
    <div class="cal-controls">
      <!-- Ruler input -->
      <div class="cal-input-row" id="calRulerInput" style="display:none">
        <label>Distance (mm):</label>
        <input type="number" id="rulerMm" min="1" max="1000" value="50" step="1"/>
      </div>
      <!-- Coin dropdown -->
      <div class="cal-input-row" id="calCoinInput" style="display:none">
        <label>Coin:</label>
        <select id="coinSelect">
          <option value="25.75">1 Euro (25.75mm)</option>
          <option value="23.25">2 Euro (23.25mm)</option>
          <option value="24.25">50 Cent (24.25mm)</option>
          <option value="22.25">10 Cent (22.25mm)</option>
          <option value="19.05">US Quarter (19.05mm)</option>
          <option value="17.91">US Nickel (17.91mm)</option>
          <option value="24.26">UK 1 pound (24.26mm)</option>
        </select>
      </div>
      <div class="cal-result" id="calResult"></div>
      <button class="cal-confirm" id="calConfirmBtn" disabled onclick="confirmCalibration()">Confirm</button>
    </div>
    <div class="cal-hint" id="calHint"><strong>Tap two points</strong> on the ruler/coin in the photo above. Tap again to redo.</div>
  </div>
</div>

<header>
  <span class="logo">BreadScan</span>
  <span class="logo-sub">v5 Â· Literature-Grounded Â· Multi-Parameter Fingerprint</span>
  <div class="logo-ref">
    <span>Thresholding:</span> Gonzales-Barron & Butler (2006) J.Food Eng.<br>
    <span>Brown bread:</span> Bosakova-Ardenska (2015) HisAnalysis peak-mode<br>
    <span>Fingerprint:</span> Ruderman et al. (2025) ScienceDirect
  </div>
</header>

<div class="layout">
<aside class="sidebar">

  <div>
    <div class="slabel">Image</div>
    <div class="upload-zone" id="dz">
      <input type="file" id="imgIn" accept="image/*"/>
      <span class="upload-icon">ğŸ</span>
      <p><strong>Drop or click to upload</strong><br>Cross-section photo or flatbed scan<br>ROI: crumb only, no crust edges</p>
    </div>
  </div>

  <!-- ROI section (shown after calibration) -->
  <div class="roi-section" id="roiSection">
    <div class="slabel">Calibration & ROI</div>
    <div class="cal-badge" id="calBadge"></div>
    <div class="roi-toggle">
      <button class="mbtn on" id="roiFull" onclick="setROIMode('full')">Full Image</button>
      <button class="mbtn" id="roiDraw" onclick="setROIMode('draw')">Draw ROI</button>
    </div>
    <div class="roi-status" id="roiStatus">Using full image for analysis.</div>
  </div>

  <div>
    <div class="slabel">Bread Type</div>
    <div class="type-row">
      <button class="tbtn on" onclick="setType('white',this)"><span class="ic">â¬œ</span>Control/White</button>
      <button class="tbtn" onclick="setType('bsg',this)"><span class="ic">ğŸŸ«</span>BSG/Dark</button>
    </div>
    <div class="algo-badge" id="algoBadge" style="margin-top:.5rem">
      <strong>Algorithm: Sauvola local adaptive</strong>
      Computes a separate threshold for each pixel based on local mean and standard deviation. Handles uneven lighting from photographic images. Applied on CLAHE-enhanced grayscale.
    </div>
  </div>

  <hr class="div"/>

  <div>
    <div class="slabel">Preprocessing</div>
    <div class="cg">
      <div class="cr"><span>Gaussian Ïƒ (denoising)</span><span class="cv" id="sgV">1.0</span></div>
      <input type="range" id="sg" min="0.0" max="3.0" value="1.0" step="0.5"/>
    </div>
    <div class="cg" style="margin-top:.5rem">
      <div class="cr"><span>CLAHE clip (contrast)</span><span class="cv" id="clV">2.0</span></div>
      <input type="range" id="cl" min="0.5" max="5.0" value="2.0" step="0.5"/>
    </div>
    <div class="ibox lit" style="margin-top:.5rem">
      <strong>Why CLAHE first?</strong> Enhances local contrast before thresholding. Used by Lassoued et al. (2008) for heterogeneous crumb structures.
    </div>
  </div>

  <div>
    <div class="slabel">BSG Mode â€” Threshold Offset</div>
    <div class="cg">
      <div class="cr"><span>Peak offset (Â±% of range)</span><span class="cv" id="ofV">+5%</span></div>
      <input type="range" id="of" min="-20" max="30" value="5" step="1"/>
    </div>
    <div class="ibox warn" style="margin-top:.5rem">
      <strong>HisAnalysis logic:</strong> threshold = histogram peak + offset, computed on RAW grayscale (no CLAHE). Negative offset (default âˆ’8%) = detect only pixels significantly darker than the dominant crumb color. More negative = more pores. Tune until binary view matches visible pores.
    </div>
  </div>

  <hr class="div"/>

  <div>
    <div class="slabel">Cell Size Filter (pxÂ²)</div>
    <div class="cg">
      <div class="cr"><span>Min cell area</span><span class="cv" id="minAV">20</span></div>
      <input type="range" id="minA" min="5" max="300" value="20" step="5"/>
    </div>
    <div class="cg" style="margin-top:.5rem">
      <div class="cr"><span>Max cell area</span><span class="cv" id="maxAV">15000</span></div>
      <input type="range" id="maxA" min="500" max="40000" value="15000" step="500"/>
    </div>
    <div class="ibox" style="margin-top:.5rem">
      <strong>No circularity filter</strong> by default. Literature shows bread pores are elliptical (circularity &lt; 1), not circular â€” filtering by shape rejects real pores. <em>Gonzales-Barron & Butler 2006.</em>
    </div>
  </div>

  <div>
    <div class="slabel">Output</div>
    <div class="cg">
      <div class="cr"><span>3D correction Ã—</span><span class="cv" id="f3V">1.50</span></div>
      <input type="range" id="f3" min="1.0" max="3.0" value="1.5" step="0.05"/>
    </div>
  </div>

  <button class="btn" id="runBtn" disabled>Analyze â€” Generate Fingerprint</button>
</aside>

<main class="main">

  <!-- Metrics row -->
  <div class="metrics">
    <div class="mc empty"><div class="ml">Void Fraction</div><div class="mv" id="m0">â€”</div><div class="mu">2D porosity %</div></div>
    <div class="mc empty"><div class="ml">3D Corrected</div><div class="mv" id="m1">â€”</div><div class="mu">estimated vol. %</div></div>
    <div class="mc empty"><div class="ml">Cell Count</div><div class="mv" id="m2">â€”</div><div class="mu">valid pores</div></div>
    <div class="mc empty"><div class="ml">Cell Density</div><div class="mv" id="m3">â€”</div><div class="mu">cells/cmÂ² (crumb fineness)</div></div>
    <div class="mc empty"><div class="ml">Mean Cell Area</div><div class="mv" id="m4">â€”</div><div class="mu">pxÂ² per pore</div></div>
    <div class="mc empty"><div class="ml">Uniformity</div><div class="mv" id="m5">â€”</div><div class="mu">CV of cell areas %</div></div>
  </div>

  <!-- Digital Texture Fingerprint -->
  <div class="fp-wrap">
    <div class="fp-head">
      <span class="fp-title">Digital Texture Fingerprint</span>
      <span class="fp-ref">after Ruderman et al. (2025) Bread Texture Analyser Â· ScienceDirect</span>
    </div>
    <div class="fp-grid" id="fpGrid">
      <div class="fp-cell"><div class="fp-param">Void Fraction</div><div class="fp-val" id="fp0">â€”</div><div class="fp-unit">% crumb area as pores</div><div class="fp-bar"><div class="fp-fill" id="fpb0" style="width:0%"></div></div></div>
      <div class="fp-cell"><div class="fp-param">Cell Density</div><div class="fp-val" id="fp1">â€”</div><div class="fp-unit">cells/100pxÂ² (fineness)</div><div class="fp-bar"><div class="fp-fill" id="fpb1" style="width:0%"></div></div></div>
      <div class="fp-cell"><div class="fp-param">Mean Cell Area</div><div class="fp-val" id="fp2">â€”</div><div class="fp-unit">pxÂ² (coarseness)</div><div class="fp-bar"><div class="fp-fill" id="fpb2" style="width:0%"></div></div></div>
      <div class="fp-cell"><div class="fp-param">Cell Uniformity</div><div class="fp-val" id="fp3">â€”</div><div class="fp-unit">1 âˆ’ CV  (1=uniform)</div><div class="fp-bar"><div class="fp-fill" id="fpb3" style="width:0%"></div></div></div>
      <div class="fp-cell"><div class="fp-param">Wall Thickness</div><div class="fp-val" id="fp4">â€”</div><div class="fp-unit">px (estimated)</div><div class="fp-bar"><div class="fp-fill" id="fpb4" style="width:0%"></div></div></div>
      <div class="fp-cell"><div class="fp-param">Macro Pore %</div><div class="fp-val" id="fp5">â€”</div><div class="fp-unit">% large cells (>2000pxÂ²)</div><div class="fp-bar"><div class="fp-fill" id="fpb5" style="width:0%"></div></div></div>
    </div>
  </div>

  <!-- Canvas grid -->
  <div class="cgrid">
    <div class="cw cw-interactive">
      <div class="clabel">Original<span class="ref"></span></div>
      <div id="ph0" class="ph">Upload</div>
      <div class="canvas-overlay-container" id="c0wrap" style="display:none">
        <canvas id="c0"></canvas>
        <canvas id="cROI"></canvas>
      </div>
    </div>
    <div class="cw">
      <div class="clabel">CLAHE enhanced<span class="ref">Lassoued 2008</span></div>
      <div id="ph1" class="ph">â€”</div>
      <canvas id="c1" style="display:none"></canvas>
    </div>
    <div class="cw">
      <div class="clabel">Binary mask<span class="ref">Sauvola / HisAnalysis</span></div>
      <div id="ph2" class="ph">â€”</div>
      <canvas id="c2" style="display:none"></canvas>
    </div>
    <div class="cw">
      <div class="clabel">Colormap by area<span class="ref">Ruderman 2025</span></div>
      <div id="ph3" class="ph">â€”</div>
      <canvas id="c3" style="display:none"></canvas>
    </div>
    <div class="cw">
      <div class="clabel">Histogram peaks<span class="ref">Bosakova 2015</span></div>
      <div id="ph4" class="ph">â€”</div>
      <canvas id="c4" style="display:none"></canvas>
    </div>
  </div>

  <!-- Histogram -->
  <div class="hist-wrap">
    <div class="hist-title">
      Cell Size Distribution
      <span style="font-size:.5rem;color:var(--muted);font-weight:normal">â€” Zghal et al. (1999) parameters â€”</span>
    </div>
    <div class="hist-bars" id="hbars">
      <div style="font-size:.6rem;color:var(--muted);width:100%;text-align:center;align-self:center">Run analysis</div>
    </div>
    <div class="pcats" id="pcats"></div>
  </div>

  <!-- Log -->
  <div>
    <div class="slabel">Analysis Log</div>
    <div class="log" id="logEl">No analysis run yet.</div>
  </div>

</main>
</div>

<!-- Working canvas (hidden) -->
<canvas id="wk" style="display:none"></canvas>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  0. STATE â€” calibration, ROI, interaction tracking
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const STATE = {
  mode: 'crumb',       // 'crumb' | 'ruler' | 'coin'
  phase: 'idle',       // 'idle' | 'calibrating' | 'roi' | 'done'
  calPts: [],          // [{x,y}, {x,y}] in image-pixel coords
  pxPerMm: null,       // pixels per mm (null = uncalibrated)
  roi: null,           // {x,y,w,h} in image-pixel coords or null
  roiMode: 'full',     // 'full' | 'draw'
  drag: null,          // drag state for ROI interaction
  imgW: 0, imgH: 0    // loaded image dimensions
};

function resetState() {
  STATE.mode = 'crumb'; STATE.phase = 'idle';
  STATE.calPts = []; STATE.pxPerMm = null;
  STATE.roi = null; STATE.roiMode = 'full'; STATE.drag = null;
  document.getElementById('roiSection').classList.remove('visible');
  document.getElementById('roiStatus').textContent = 'Using full image for analysis.';
  setROIBtnState('full');
  drawOverlay();
}

// â”€â”€ Upload choice modal â”€â”€
function showUploadModal() {
  document.getElementById('uploadModal').style.display = 'flex';
}

function chooseMode(mode) {
  document.getElementById('uploadModal').style.display = 'none';
  STATE.mode = mode;
  if (mode === 'crumb') {
    STATE.phase = 'done';
    document.getElementById('runBtn').disabled = false;
    return;
  }
  // Show calibration modal with the image
  showCalModal(mode);
}

// â”€â”€ Calibration modal â”€â”€
function showCalModal(mode) {
  STATE.phase = 'calibrating';
  STATE.calPts = [];
  STATE.pxPerMm = null;

  // Set title and controls
  const isRuler = mode === 'ruler';
  document.getElementById('calModalTitle').textContent = isRuler ? 'Calibrate with ruler' : 'Calibrate with coin';
  document.getElementById('calRulerInput').style.display = isRuler ? 'flex' : 'none';
  document.getElementById('calCoinInput').style.display = isRuler ? 'none' : 'flex';
  document.getElementById('calResult').textContent = '';
  document.getElementById('calConfirmBtn').disabled = true;
  document.getElementById('calSteps').innerHTML = '<strong>Step 1:</strong> Touch the first point';
  document.getElementById('calHint').innerHTML = isRuler
    ? '<strong>Tap two points</strong> on the ruler in the photo above'
    : '<strong>Tap two points</strong> on opposite edges of the coin';

  // Draw the uploaded image on the modal canvas
  const wk = document.getElementById('wk');
  const cImg = document.getElementById('cCalImg');
  cImg.width = STATE.imgW; cImg.height = STATE.imgH;
  cImg.getContext('2d').drawImage(wk, 0, 0);

  // Clear overlay
  const cOv = document.getElementById('cCalOverlay');
  cOv.width = STATE.imgW; cOv.height = STATE.imgH;
  cOv.getContext('2d').clearRect(0, 0, cOv.width, cOv.height);

  document.getElementById('calModal').style.display = 'flex';
}

function drawCalOverlay() {
  const cv = document.getElementById('cCalOverlay');
  if (!STATE.imgW || !STATE.imgH) return;
  cv.width = STATE.imgW; cv.height = STATE.imgH;
  const ctx = cv.getContext('2d');
  ctx.clearRect(0, 0, cv.width, cv.height);

  if (STATE.calPts.length > 0) {
    ctx.fillStyle = '#e8c97a'; ctx.strokeStyle = '#e8c97a'; ctx.lineWidth = 3;
    for (const p of STATE.calPts) {
      ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI * 2); ctx.fill();
      // Crosshair
      ctx.strokeStyle = 'rgba(232,201,122,0.5)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(p.x - 18, p.y); ctx.lineTo(p.x + 18, p.y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(p.x, p.y - 18); ctx.lineTo(p.x, p.y + 18); ctx.stroke();
      ctx.strokeStyle = '#e8c97a'; ctx.lineWidth = 3;
    }
    if (STATE.calPts.length === 2) {
      const [a, b] = STATE.calPts;
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      const dist = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
      const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
      ctx.font = 'bold 16px DM Mono'; ctx.fillStyle = '#e8c97a'; ctx.textAlign = 'center';
      const label = STATE.pxPerMm ? `${(dist / STATE.pxPerMm).toFixed(1)}mm` : `${dist.toFixed(0)}px`;
      // Background for text readability
      const tw = ctx.measureText(label).width;
      ctx.fillStyle = 'rgba(15,14,11,0.7)';
      ctx.fillRect(mx - tw/2 - 4, my - 24, tw + 8, 20);
      ctx.fillStyle = '#e8c97a';
      ctx.fillText(label, mx, my - 10);
    }
  }
}

function calcCalibration() {
  if (STATE.calPts.length < 2) return;
  const [a, b] = STATE.calPts;
  const distPx = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
  let mmVal;
  if (STATE.mode === 'ruler') {
    mmVal = parseFloat(document.getElementById('rulerMm').value);
    if (!mmVal || mmVal <= 0) return;
  } else {
    mmVal = parseFloat(document.getElementById('coinSelect').value);
  }
  STATE.pxPerMm = distPx / mmVal;
  document.getElementById('calResult').innerHTML =
    `<strong>${STATE.pxPerMm.toFixed(2)} px/mm</strong>`;
  document.getElementById('calConfirmBtn').disabled = false;
  document.getElementById('calSteps').innerHTML = '<strong>Done!</strong> Confirm or tap to redo';
  drawCalOverlay();
}

function confirmCalibration() {
  if (!STATE.pxPerMm) return;
  document.getElementById('calModal').style.display = 'none';
  STATE.phase = 'roi';
  // Show ROI section with calibration badge
  const roiSec = document.getElementById('roiSection');
  roiSec.classList.add('visible');
  document.getElementById('calBadge').innerHTML =
    `<strong>${STATE.pxPerMm.toFixed(2)} px/mm</strong> â€” calibrated with ${STATE.mode}`;
  document.getElementById('runBtn').disabled = false;
  drawOverlay();
}

function initCalModalEvents() {
  const cv = document.getElementById('cCalOverlay');

  function calCoords(e) {
    const rect = cv.getBoundingClientRect();
    const t = e.touches ? e.touches[0] || e.changedTouches[0] : e;
    const scaleX = STATE.imgW / rect.width;
    const scaleY = STATE.imgH / rect.height;
    return { x: (t.clientX - rect.left) * scaleX, y: (t.clientY - rect.top) * scaleY };
  }

  cv.addEventListener('pointerdown', (e) => {
    if (STATE.phase !== 'calibrating') return;
    e.preventDefault();
    const pt = calCoords(e);

    if (STATE.calPts.length < 2) {
      STATE.calPts.push(pt);
      drawCalOverlay();
      if (STATE.calPts.length === 1) {
        document.getElementById('calSteps').innerHTML = '<strong>Step 2:</strong> Touch the second point';
      }
      if (STATE.calPts.length === 2) calcCalibration();
    } else {
      // Redo: reset points
      STATE.calPts = [pt];
      STATE.pxPerMm = null;
      document.getElementById('calResult').textContent = '';
      document.getElementById('calConfirmBtn').disabled = true;
      document.getElementById('calSteps').innerHTML = '<strong>Step 2:</strong> Touch the second point';
      drawCalOverlay();
    }
  });
}

// â”€â”€ ROI mode â”€â”€
function setROIMode(mode) {
  STATE.roiMode = mode;
  setROIBtnState(mode);
  if (mode === 'full') {
    STATE.roi = null;
    document.getElementById('roiStatus').textContent = 'Using full image for analysis.';
    drawOverlay();
    if (!document.getElementById('runBtn').disabled) analyze();
  } else {
    document.getElementById('roiStatus').innerHTML = '<strong>Click and drag</strong> on the image to select the crumb region.';
    drawOverlay();
  }
}

function setROIBtnState(mode) {
  document.getElementById('roiFull').classList.toggle('on', mode === 'full');
  document.getElementById('roiDraw').classList.toggle('on', mode === 'draw');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  1. GRAYSCALE & BLUR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function toGray(data, w, h) {
  const g = new Float32Array(w * h);
  for (let i = 0; i < w * h; i++)
    g[i] = (0.299 * data[i*4] + 0.587 * data[i*4+1] + 0.114 * data[i*4+2]) / 255;
  return g;
}

function gaussBlur(src, w, h, sigma) {
  if (sigma < 0.1) return new Float32Array(src);
  const r = Math.max(1, Math.ceil(sigma * 2.5));
  const k = []; let ks = 0;
  for (let i = -r; i <= r; i++) { const v = Math.exp(-(i*i)/(2*sigma*sigma)); k.push(v); ks += v; }
  for (let i = 0; i < k.length; i++) k[i] /= ks;
  const tmp = new Float32Array(w*h), out = new Float32Array(w*h);
  for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
    let a = 0;
    for (let ki = -r; ki <= r; ki++) a += src[y*w + Math.min(Math.max(x+ki,0),w-1)] * k[ki+r];
    tmp[y*w+x] = a;
  }
  for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
    let a = 0;
    for (let ki = -r; ki <= r; ki++) a += tmp[Math.min(Math.max(y+ki,0),h-1)*w+x] * k[ki+r];
    out[y*w+x] = a;
  }
  return out;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  2. CLAHE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function clahe(gray, w, h, tileSize, clip) {
  const out = new Float32Array(w*h);
  const tx = Math.ceil(w/tileSize), ty = Math.ceil(h/tileSize);
  const cdfs = [];
  for (let tyy = 0; tyy < ty; tyy++) for (let txx = 0; txx < tx; txx++) {
    const hist = new Float32Array(256);
    const x0=txx*tileSize, x1=Math.min(x0+tileSize,w);
    const y0=tyy*tileSize, y1=Math.min(y0+tileSize,h);
    let n = 0;
    for (let y=y0;y<y1;y++) for (let x=x0;x<x1;x++) { hist[Math.round(gray[y*w+x]*255)]++; n++; }
    const ct = clip * n / 256;
    let ex = 0;
    for (let i=0;i<256;i++) { if(hist[i]>ct){ex+=hist[i]-ct;hist[i]=ct;} }
    const rd = ex / 256;
    for (let i=0;i<256;i++) hist[i] += rd;
    const cdf = new Float32Array(256); cdf[0] = hist[0];
    for (let i=1;i<256;i++) cdf[i] = cdf[i-1] + hist[i];
    const cmin = cdf.findIndex(v=>v>0)||0;
    for (let i=0;i<256;i++) cdf[i] = Math.max(0, (cdf[i]-cmin) / Math.max(1, n-cmin));
    cdfs.push(cdf);
  }
  for (let y=0;y<h;y++) for (let x=0;x<w;x++) {
    const b = Math.round(gray[y*w+x]*255);
    const txf=(x/tileSize)-0.5, tyf=(y/tileSize)-0.5;
    const tx0=Math.max(0,Math.floor(txf)), tx1=Math.min(tx-1,tx0+1);
    const ty0=Math.max(0,Math.floor(tyf)), ty1=Math.min(ty-1,ty0+1);
    const wx=txf-tx0, wy=tyf-ty0;
    out[y*w+x]=(cdfs[ty0*tx+tx0][b]*(1-wx)*(1-wy))
              +(cdfs[ty0*tx+tx1][b]*wx*(1-wy))
              +(cdfs[ty1*tx+tx0][b]*(1-wx)*wy)
              +(cdfs[ty1*tx+tx1][b]*wx*wy);
  }
  return out;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  3. THRESHOLDING â€” LITERATURE-GROUNDED
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Otsu â€” used for histogram visualization reference
function otsu(arr) {
  const hist = new Float32Array(256);
  for (let i=0;i<arr.length;i++) hist[Math.round(arr[i]*255)]++;
  const total = arr.length;
  let sum = 0; for (let i=0;i<256;i++) sum += i*hist[i];
  let sB=0, wB=0, best=0, thresh=128;
  for (let i=0;i<256;i++){
    wB += hist[i]; if(!wB) continue;
    const wF = total-wB; if(!wF) break;
    sB += i*hist[i];
    const mB=sB/wB, mF=(sum-sB)/wF;
    const v = wB*wF*(mB-mF)**2;
    if(v>best){best=v;thresh=i;}
  }
  return thresh/255; // normalized
}

// Sauvola local adaptive thresholding â€” handles uneven lighting
// T(x,y) = Î¼(x,y) Ã— [1 + k Ã— (Ïƒ(x,y)/R - 1)]
// Uses integral images for O(1) per-pixel mean/variance computation
function sauvolaBinarize(arr, w, h, winSize, k) {
  winSize = winSize || 51;
  k = k || 0.2;
  const R = 0.5; // dynamic range for [0,1] normalized data
  const half = Math.floor(winSize / 2);
  const out = new Uint8Array(w * h);

  // Build integral images for sum and sum-of-squares
  const iw = w + 1, ih = h + 1;
  const intS = new Float64Array(iw * ih);
  const intQ = new Float64Array(iw * ih);
  for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
    const v = arr[y * w + x];
    const i1 = (y+1)*iw + (x+1);
    intS[i1] = v   + intS[y*iw+(x+1)] + intS[(y+1)*iw+x] - intS[y*iw+x];
    intQ[i1] = v*v + intQ[y*iw+(x+1)] + intQ[(y+1)*iw+x] - intQ[y*iw+x];
  }

  for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
    const x0 = Math.max(0, x - half), y0 = Math.max(0, y - half);
    const x1 = Math.min(w-1, x + half), y1 = Math.min(h-1, y + half);
    const n = (x1-x0+1) * (y1-y0+1);
    const s = intS[(y1+1)*iw+(x1+1)] - intS[y0*iw+(x1+1)] - intS[(y1+1)*iw+x0] + intS[y0*iw+x0];
    const q = intQ[(y1+1)*iw+(x1+1)] - intQ[y0*iw+(x1+1)] - intQ[(y1+1)*iw+x0] + intQ[y0*iw+x0];
    const mean = s / n;
    const std = Math.sqrt(Math.max(0, q/n - mean*mean));
    const thresh = mean * (1 + k * (std / R - 1));
    out[y*w+x] = arr[y*w+x] < thresh ? 1 : 0;
  }
  return out;
}

// HisAnalysis â€” peak-mode threshold for BROWN bread
// After Bosakova-Ardenska (2015): threshold = mode of histogram + offset
// Pixels DARKER than this value are pores
function hisAnalysisPeakMode(arr, offsetPct) {
  const hist = new Float32Array(256);
  for (let i=0;i<arr.length;i++) hist[Math.round(arr[i]*255)]++;
  // Find the dominant peak (most frequent intensity = the crumb matrix color)
  let peakBin = 0, peakVal = 0;
  for (let i=0;i<256;i++) if(hist[i]>peakVal){peakVal=hist[i];peakBin=i;}
  // offset shifts threshold relative to full range
  const offsetBins = Math.round(offsetPct * 2.56); // offsetPct is -20..+30
  const thresh = Math.min(255, Math.max(0, peakBin + offsetBins));
  return { tNorm: thresh/255, peakBin, thresh };
}

// Build histogram for visualization (200Ã—100 canvas)
function buildHistCanvas(canvasId, arr, threshNorm, peakBin) {
  const cv = document.getElementById(canvasId);
  const W2 = 256, H2 = 80;
  cv.width = W2; cv.height = H2;
  const ctx = cv.getContext('2d');
  ctx.fillStyle = '#0f0e0b'; ctx.fillRect(0,0,W2,H2);

  const hist = new Float32Array(256);
  for (let i=0;i<arr.length;i++) hist[Math.round(arr[i]*255)]++;
  const maxH = Math.max(...hist);

  for (let i=0;i<256;i++){
    const barH = Math.round((hist[i]/maxH) * (H2-4));
    const x = i;
    // color: dark = pore zone, light = crumb zone
    const t255 = Math.round(threshNorm*255);
    ctx.fillStyle = i < t255 ? 'rgba(201,168,76,0.9)' : 'rgba(122,100,50,0.35)';
    ctx.fillRect(x, H2-barH, 1, barH);
  }
  // Draw threshold line
  const tx = Math.round(threshNorm*255);
  ctx.strokeStyle = '#e8c97a'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(tx,0); ctx.lineTo(tx,H2); ctx.stroke();
  // Draw peak marker
  if (peakBin !== undefined){
    ctx.strokeStyle = 'rgba(212,130,74,0.8)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(peakBin,0); ctx.lineTo(peakBin,H2); ctx.stroke();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  4. MORPHOLOGICAL OPS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function dilate(bin,w,h,r){
  r = r || 1;
  const o=new Uint8Array(w*h);
  for(let y=0;y<h;y++) for(let x=0;x<w;x++){
    let f=0;
    for(let dy=-r;dy<=r&&!f;dy++) for(let dx=-r;dx<=r&&!f;dx++){
      const nx=x+dx,ny=y+dy;
      if(nx>=0&&nx<w&&ny>=0&&ny<h&&bin[ny*w+nx])f=1;
    }
    o[y*w+x]=f;
  }
  return o;
}
function erode(bin,w,h,r){
  r = r || 1;
  const o=new Uint8Array(w*h);
  for(let y=0;y<h;y++) for(let x=0;x<w;x++){
    let a=1;
    for(let dy=-r;dy<=r&&a;dy++) for(let dx=-r;dx<=r&&a;dx++){
      const nx=x+dx,ny=y+dy;
      if(nx<0||nx>=w||ny<0||ny>=h||!bin[ny*w+nx])a=0;
    }
    o[y*w+x]=a;
  }
  return o;
}
function morphClose(b,w,h,r){ r=r||1; return erode(dilate(b,w,h,r),w,h,r); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  5. CONNECTED COMPONENTS + METRICS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function labelBlobs(bin, w, h) {
  const vis = new Uint8Array(w*h);
  const blobs = [];
  for (let y=0;y<h;y++) for (let x=0;x<w;x++){
    const idx = y*w+x;
    if (!bin[idx]||vis[idx]) continue;
    const q=[idx]; vis[idx]=1; const pix=[];
    while(q.length){
      const c=q.pop(); const cx=c%w, cy=Math.floor(c/w);
      pix.push([cx,cy]);
      // 8-connectivity: cardinal + diagonal neighbors
      for (const nb of [c-1,c+1,c-w,c+w,c-w-1,c-w+1,c+w-1,c+w+1]){
        const nx=nb%w, ny=Math.floor(nb/w);
        if(nb<0||nb>=w*h||Math.abs(nx-cx)>1||Math.abs(ny-cy)>1||vis[nb]||!bin[nb]) continue;
        vis[nb]=1; q.push(nb);
      }
    }
    const area=pix.length; if(area<3) continue;
    let sx=0,sy=0;
    for(const[px,py] of pix){sx+=px;sy+=py;}
    blobs.push({area, cx:sx/area, cy:sy/area, pix});
  }
  return blobs;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  6. COLORMAP CANVAS (Ruderman 2025 technique)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Heatmap from small (purple/blue) â†’ large (yellow/red) cells
function areaToColor(area, minA, maxA) {
  const t = maxA > minA ? Math.pow((area-minA)/(maxA-minA), 0.4) : 0;
  // Color ramp: blue â†’ cyan â†’ green â†’ yellow â†’ red
  const stops = [
    [0,   [60,  80, 180]],
    [0.25,[40, 160, 180]],
    [0.5, [80, 180,  80]],
    [0.75,[200,180,  40]],
    [1.0, [210, 60,  40]],
  ];
  for (let i=0;i<stops.length-1;i++){
    const [t0,c0]=stops[i], [t1,c1]=stops[i+1];
    if(t>=t0&&t<=t1){
      const f=(t-t0)/(t1-t0);
      return c0.map((v,j)=>Math.round(v+(c1[j]-v)*f));
    }
  }
  return [210,60,40];
}

function drawColormap(canvasId, w, h, validBlobs, minA, maxA) {
  const cv = document.getElementById(canvasId); cv.width=w; cv.height=h;
  const ctx = cv.getContext('2d');
  ctx.fillStyle = '#0f0e0b'; ctx.fillRect(0,0,w,h);
  for (const b of validBlobs) {
    const [r,g,bl2] = areaToColor(b.area, minA, maxA);
    ctx.fillStyle = `rgba(${r},${g},${bl2},0.92)`;
    for (const [px,py] of b.pix) ctx.fillRect(px,py,1,1);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  7. RENDER HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function grayToCanvas(id, arr, w, h){
  const cv=document.getElementById(id); cv.width=w; cv.height=h;
  const ctx=cv.getContext('2d'); const d=ctx.createImageData(w,h);
  for(let i=0;i<w*h;i++){const v=Math.round(Math.min(1,Math.max(0,arr[i]))*255);d.data[i*4]=v;d.data[i*4+1]=v;d.data[i*4+2]=v;d.data[i*4+3]=255;}
  ctx.putImageData(d,0,0);
}

function binToCanvas(id, bin, w, h){
  const cv=document.getElementById(id); cv.width=w; cv.height=h;
  const ctx=cv.getContext('2d'); const d=ctx.createImageData(w,h);
  for(let i=0;i<w*h;i++){
    if(bin[i]){d.data[i*4]=201;d.data[i*4+1]=168;d.data[i*4+2]=76;}
    else{d.data[i*4]=15;d.data[i*4+1]=14;d.data[i*4+2]=11;}
    d.data[i*4+3]=255;
  }
  ctx.putImageData(d,0,0);
}

function show(cid, phid){
  document.getElementById(phid).style.display='none';
  document.getElementById(cid).style.display='block';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  8. HISTOGRAM + FINGERPRINT RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CAT_COLORS = ['#7a9ab8','#7ab87a','#c9a84c','#d4824a','#c97a6a'];

function renderHist(blobs, total, cal) {
  const hEl=document.getElementById('hbars'), pEl=document.getElementById('pcats');
  hEl.innerHTML=''; pEl.innerHTML='';
  if(!blobs.length){hEl.innerHTML='<div style="font-size:.6rem;color:var(--muted);width:100%;text-align:center;align-self:center">No cells detected</div>';return;}
  const u = cal ? 'mmÂ²' : 'pxÂ²';
  const cv = (px2) => cal ? px2 / (cal * cal) : px2;
  const cats = cal ? [
    {l:`Micro\n<${cv(50).toFixed(1)}${u}`,min:0,max:50},
    {l:`Small\n${cv(50).toFixed(1)}â€“${cv(200).toFixed(0)}`,min:50,max:200},
    {l:`Medium\n${cv(200).toFixed(0)}â€“${cv(1000).toFixed(0)}`,min:200,max:1000},
    {l:`Large\n${cv(1000).toFixed(0)}â€“${cv(5000).toFixed(0)}`,min:1000,max:5000},
    {l:`Macro\n>${cv(5000).toFixed(0)}${u}`,min:5000,max:Infinity}
  ] : [
    {l:'Micro\n<50pxÂ²',min:0,max:50},
    {l:'Small\n50â€“200',min:50,max:200},
    {l:'Medium\n200â€“1k',min:200,max:1000},
    {l:'Large\n1kâ€“5k',min:1000,max:5000},
    {l:'Macro\n>5k',min:5000,max:Infinity}
  ];
  const counts=cats.map(c=>blobs.filter(b=>b.area>=c.min&&b.area<c.max).length);
  const areas=cats.map(c=>blobs.filter(b=>b.area>=c.min&&b.area<c.max).reduce((s,b)=>s+b.area,0));
  const mx=Math.max(...counts,1);
  cats.forEach((c,i)=>{
    const bg=document.createElement('div'); bg.className='bg2';
    const bar=document.createElement('div'); bar.className='bar';
    bar.style.height=Math.round(counts[i]/mx*65)+'px';
    bar.style.background=CAT_COLORS[i];
    const tick=document.createElement('div'); tick.className='btick'; tick.textContent=counts[i];
    bg.appendChild(bar); bg.appendChild(tick);
    hEl.appendChild(bg);

    const p=document.createElement('div'); p.className='pcat';
    const pct = total>0?(areas[i]/total*100).toFixed(1):'0';
    p.innerHTML=`<div class="pcat-l">${c.l.replace('\n','<br>')}</div><div class="pcat-v" style="color:${CAT_COLORS[i]}">${counts[i]}</div><div class="pcat-pct">${pct}% area</div>`;
    pEl.appendChild(p);
  });
}

function renderFingerprint(blobs, totalPx, W, H, cal) {
  const areas = blobs.map(b=>b.area);
  const voidFrac = blobs.length ? areas.reduce((s,a)=>s+a,0)/totalPx : 0;
  const u = cal ? 'mmÂ²' : 'pxÂ²';
  const toU = (px2) => cal ? px2 / (cal * cal) : px2;
  const cellDensity = cal
    ? blobs.length / (totalPx / (cal * cal) / 100)
    : blobs.length / (totalPx / 10000);
  const densU = cal ? 'cells/cmÂ²' : 'cells/100pxÂ²';
  const meanA = blobs.length ? areas.reduce((s,a)=>s+a,0)/areas.length : 0;
  const variance = blobs.length ? areas.reduce((s,a)=>s+(a-meanA)**2,0)/areas.length : 0;
  const cv = meanA > 0 ? Math.sqrt(variance)/meanA : 0;
  const uniformity = Math.max(0, 1-cv);
  const solidArea = totalPx - areas.reduce((s,a)=>s+a,0);
  const wallThick = blobs.length>0 ? Math.sqrt(solidArea/blobs.length) : 0;
  const wallUnit = cal ? 'mm' : 'px';
  const wallDisp = cal ? wallThick / cal : wallThick;
  const macroArea = areas.filter(a=>a>2000).reduce((s,a)=>s+a,0);
  const macroPct = macroArea/totalPx*100;
  const macroThresh = cal ? toU(2000).toFixed(1)+u : '2000pxÂ²';

  const fmt=(v,d=1)=>isNaN(v)?'â€”':v.toFixed(d);
  const setFP=(id,bid,val,maxVal,txt,unitTxt)=>{
    document.getElementById(id).textContent=txt||fmt(val);
    const pct = Math.min(100, Math.round(val/maxVal*100));
    document.getElementById(bid).style.width=pct+'%';
    if(unitTxt){const cell=document.getElementById(id).closest('.fp-cell');const uEl=cell.querySelector('.fp-unit');if(uEl)uEl.textContent=unitTxt;}
  };
  setFP('fp0','fpb0',voidFrac*100,100, fmt(voidFrac*100)+'%','% crumb area as pores');
  setFP('fp1','fpb1',cellDensity,2, fmt(cellDensity,2),densU+' (fineness)');
  const meanDisp = cal ? toU(meanA).toFixed(2) : String(Math.round(meanA));
  setFP('fp2','fpb2',cal?toU(meanA):meanA, cal?toU(5000):5000, meanDisp, u+' (coarseness)');
  setFP('fp3','fpb3',uniformity*100,100, fmt(uniformity*100)+'%','1 âˆ’ CV  (1=uniform)');
  setFP('fp4','fpb4',wallDisp,cal?5:50, fmt(wallDisp,1)+wallUnit, wallUnit+' (estimated)');
  setFP('fp5','fpb5',macroPct,50, fmt(macroPct)+'%','% large cells (>'+macroThresh+')');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  8b. OVERLAY CANVAS â€” calibration points + ROI rect
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function canvasCoords(e, canvas) {
  const rect = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] || e.changedTouches[0] : e;
  const scaleX = STATE.imgW / rect.width;
  const scaleY = STATE.imgH / rect.height;
  return {
    x: (t.clientX - rect.left) * scaleX,
    y: (t.clientY - rect.top) * scaleY
  };
}

function drawOverlay() {
  const cv = document.getElementById('cROI');
  if (!STATE.imgW || !STATE.imgH) return;
  cv.width = STATE.imgW; cv.height = STATE.imgH;
  const ctx = cv.getContext('2d');
  ctx.clearRect(0, 0, cv.width, cv.height);

  // Draw ROI rectangle with dimmed outside
  if (STATE.roi) {
    const r = STATE.roi;
    // Dim area outside ROI
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, 0, cv.width, r.y);
    ctx.fillRect(0, r.y, r.x, r.h);
    ctx.fillRect(r.x + r.w, r.y, cv.width - r.x - r.w, r.h);
    ctx.fillRect(0, r.y + r.h, cv.width, cv.height - r.y - r.h);
    // ROI border
    ctx.strokeStyle = '#c9a84c'; ctx.lineWidth = 2;
    ctx.strokeRect(r.x, r.y, r.w, r.h);
    // Corner handles
    const hs = 8;
    ctx.fillStyle = '#c9a84c';
    for (const [cx, cy] of [[r.x, r.y], [r.x + r.w, r.y], [r.x, r.y + r.h], [r.x + r.w, r.y + r.h]]) {
      ctx.fillRect(cx - hs / 2, cy - hs / 2, hs, hs);
    }
    // Size label
    if (STATE.pxPerMm) {
      const mmW = (r.w / STATE.pxPerMm).toFixed(1), mmH = (r.h / STATE.pxPerMm).toFixed(1);
      ctx.font = '12px DM Mono'; ctx.fillStyle = '#e8c97a'; ctx.textAlign = 'center';
      ctx.fillText(`${mmW} x ${mmH} mm`, r.x + r.w / 2, r.y - 8);
    }
  }
}

function normalizeROI(r) {
  let { x, y, w, h } = r;
  if (w < 0) { x += w; w = -w; }
  if (h < 0) { y += h; h = -h; }
  x = Math.max(0, Math.min(x, STATE.imgW - 1));
  y = Math.max(0, Math.min(y, STATE.imgH - 1));
  w = Math.min(w, STATE.imgW - x);
  h = Math.min(h, STATE.imgH - y);
  return { x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h) };
}

function hitTestROI(px, py) {
  if (!STATE.roi) return null;
  const r = STATE.roi, margin = 12;
  // Corners
  const corners = [
    { name: 'tl', cx: r.x, cy: r.y },
    { name: 'tr', cx: r.x + r.w, cy: r.y },
    { name: 'bl', cx: r.x, cy: r.y + r.h },
    { name: 'br', cx: r.x + r.w, cy: r.y + r.h }
  ];
  for (const c of corners) {
    if (Math.abs(px - c.cx) < margin && Math.abs(py - c.cy) < margin) return c.name;
  }
  // Inside â†’ move
  if (px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h) return 'move';
  return null;
}

function initOverlayEvents() {
  const cv = document.getElementById('cROI');

  function onDown(e) {
    e.preventDefault();
    const pt = canvasCoords(e, cv);

    // ROI drawing only (calibration is handled in the cal modal)
    if (STATE.roiMode !== 'draw') return;
    const hit = hitTestROI(pt.x, pt.y);
    if (hit === 'move') {
      STATE.drag = { type: 'move', sx: pt.x, sy: pt.y, origROI: { ...STATE.roi } };
    } else if (hit) {
      STATE.drag = { type: 'resize', corner: hit, sx: pt.x, sy: pt.y, origROI: { ...STATE.roi } };
    } else {
      // New ROI
      STATE.roi = { x: pt.x, y: pt.y, w: 0, h: 0 };
      STATE.drag = { type: 'new', sx: pt.x, sy: pt.y };
    }
  }

  function onMove(e) {
    if (!STATE.drag) return;
    e.preventDefault();
    const pt = canvasCoords(e, cv);
    const d = STATE.drag;

    if (d.type === 'new') {
      STATE.roi = normalizeROI({ x: d.sx, y: d.sy, w: pt.x - d.sx, h: pt.y - d.sy });
    } else if (d.type === 'move') {
      const dx = pt.x - d.sx, dy = pt.y - d.sy;
      let nx = d.origROI.x + dx, ny = d.origROI.y + dy;
      nx = Math.max(0, Math.min(nx, STATE.imgW - d.origROI.w));
      ny = Math.max(0, Math.min(ny, STATE.imgH - d.origROI.h));
      STATE.roi = { x: Math.round(nx), y: Math.round(ny), w: d.origROI.w, h: d.origROI.h };
    } else if (d.type === 'resize') {
      const r = { ...d.origROI };
      const c = d.corner;
      if (c.includes('r')) { r.w = pt.x - r.x; }
      if (c.includes('l')) { r.w = (r.x + r.w) - pt.x; r.x = pt.x; }
      if (c.includes('b')) { r.h = pt.y - r.y; }
      if (c.includes('t')) { r.h = (r.y + r.h) - pt.y; r.y = pt.y; }
      STATE.roi = normalizeROI(r);
    }
    updateROIStatus();
    drawOverlay();
  }

  function onUp(e) {
    if (!STATE.drag) return;
    STATE.drag = null;
    if (STATE.roi && STATE.roi.w > 5 && STATE.roi.h > 5) {
      updateROIStatus();
      drawOverlay();
      if (!document.getElementById('runBtn').disabled) analyze();
    }
  }

  cv.addEventListener('pointerdown', onDown);
  cv.addEventListener('pointermove', onMove);
  cv.addEventListener('pointerup', onUp);
  cv.addEventListener('pointercancel', onUp);
}

function updateROIStatus() {
  if (!STATE.roi) return;
  const r = STATE.roi;
  let txt = `ROI: ${r.w}x${r.h} px`;
  if (STATE.pxPerMm) {
    const mmW = (r.w / STATE.pxPerMm).toFixed(1), mmH = (r.h / STATE.pxPerMm).toFixed(1);
    txt += ` (${mmW}x${mmH} mm)`;
  }
  document.getElementById('roiStatus').innerHTML = `<strong>${txt}</strong>`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  9. MAIN ANALYSIS PIPELINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function analyze() {
  const log = [], t0 = performance.now();
  const type   = document.getElementById('wk').dataset.type || 'white';
  const sigma  = parseFloat(document.getElementById('sg').value);
  const clip   = parseFloat(document.getElementById('cl').value);
  const ofPct  = parseInt(document.getElementById('of').value);
  const minA   = parseInt(document.getElementById('minA').value);
  const maxA   = parseInt(document.getElementById('maxA').value);
  const f3d    = parseFloat(document.getElementById('f3').value);

  const wk = document.getElementById('wk');
  let W, H, imgData;
  // ROI cropping: analyze only the selected region
  if (STATE.roi && STATE.roi.w > 5 && STATE.roi.h > 5) {
    const r = STATE.roi;
    W = r.w; H = r.h;
    imgData = wk.getContext('2d').getImageData(r.x, r.y, W, H);
  } else {
    W = wk.width; H = wk.height;
    imgData = wk.getContext('2d').getImageData(0, 0, W, H);
  }
  const cal = STATE.pxPerMm;
  const unit = cal ? 'mmÂ²' : 'pxÂ²';
  const toUnit = (px2) => cal ? px2 / (cal * cal) : px2;

  log.push(`Image: ${wk.width}Ã—${wk.height}${STATE.roi ? ` â†’ ROI: ${W}Ã—${H}` : ''}  |  Type: ${type}  |  Ïƒ=${sigma}  |  CLAHE clip=${clip}`);
  if (cal) log.push(`Calibration: ${cal.toFixed(2)} px/mm  |  Units: ${unit}`);

  // Step 1: Grayscale + blur
  let gray = toGray(imgData.data, W, H);
  gray = gaussBlur(gray, W, H, sigma);

  // Step 2: CLAHE
  const enhanced = clahe(gray, W, H, 32, clip);

  // Step 3: Threshold â€” algorithm chosen by bread type
  let binary, tNorm, peakBin, algoName;
  if (type === 'white') {
    // Sauvola local adaptive thresholding on CLAHE-enhanced image.
    // Handles uneven lighting by computing a separate threshold for each pixel
    // based on local mean and standard deviation in a 51px window.
    // Otsu fails on photographic images with lighting gradients because a single
    // global threshold cannot serve both bright and dark regions simultaneously.
    binary = sauvolaBinarize(enhanced, W, H, 51, 0.2);
    tNorm = otsu(enhanced); // compute Otsu for histogram visualization reference only
    peakBin = undefined;
    algoName = 'Sauvola local adaptive (w=51, k=0.2) on CLAHE-enhanced';
    log.push(`[LIT] Sauvola local adaptive threshold (window=51px, k=0.2)`);
    log.push(`      â†³ T(x,y) = Î¼(x,y) Ã— [1 + k Ã— (Ïƒ(x,y)/R âˆ’ 1)]`);
    log.push(`      â†³ Handles uneven lighting â€” each pixel gets its own threshold`);
    log.push(`      Otsu reference threshold: ${(tNorm*255).toFixed(1)}/255 (for histogram view only)`);
  } else {
    // BSG/dark bread: compute HisAnalysis on RAW blurred grayscale, NOT on CLAHE output.
    // Bosakova-Ardenska (2015) operates on unenhanced grayscale where the histogram
    // peak represents the dominant crumb color. CLAHE flattens the histogram,
    // destroying the peak and producing a meaningless threshold.
    const res = hisAnalysisPeakMode(gray, ofPct);
    tNorm = res.tNorm; peakBin = res.peakBin; algoName = 'HisAnalysis peak-mode (Bosakova-Ardenska 2015)';
    binary = new Uint8Array(W*H);
    for(let i=0;i<gray.length;i++) binary[i] = gray[i] < tNorm ? 1 : 0;
    log.push(`[LIT] HisAnalysis on RAW grayscale (no CLAHE) â€” faithful to Bosakova 2015`);
    log.push(`[LIT] Histogram peak at bin ${peakBin} (${(peakBin/255*100).toFixed(1)}%) â€” dominant crumb color`);
    log.push(`[LIT] Threshold = peak + (${ofPct}%) offset = bin ${res.thresh} (${(tNorm*100).toFixed(1)}%)`);
    log.push(`      â†³ Pixels DARKER than this threshold are classified as pores`);
  }

  const rawPx = binary.reduce((s,v)=>s+v,0);
  log.push(`Raw dark pixels: ${rawPx} (${(rawPx/W/H*100).toFixed(1)}%)`);

  // Step 4: Morphological close
  // BSG: radius 3 to bridge fragmented pore regions caused by fiber texture
  // White: radius 1 (pores are well-defined, larger closing would merge them)
  const morphR = type === 'white' ? 1 : 3;
  const closed = morphClose(binary, W, H, morphR);
  const closedPx = closed.reduce((s,v)=>s+v,0);
  log.push(`After morph-close (r=${morphR}): ${closedPx} px (${(closedPx/W/H*100).toFixed(1)}%)`);

  // Step 5: Label blobs + size filter only (NO circularity filter â€” per Gonzales-Barron 2006)
  const allBlobs = labelBlobs(closed, W, H);
  const valid = allBlobs.filter(b => b.area >= minA && b.area <= maxA);
  const tooSmall = allBlobs.filter(b => b.area < minA).length;
  const tooLarge = allBlobs.filter(b => b.area > maxA).length;

  log.push(`Blobs: ${allBlobs.length} total  â†’  ${valid.length} valid  (${tooSmall} too small, ${tooLarge} too large)`);
  log.push(`[NOTE] No circularity filter â€” bread pores are elliptical (Gonzales-Barron 2006)`);

  // Step 6: Metrics
  const totalPx = W*H;
  const porePx  = valid.reduce((s,b)=>s+b.area,0);
  const vf2d    = porePx/totalPx;
  const vf3d    = Math.min(vf2d*f3d,1);
  // Density: cells per cmÂ² if calibrated, else cells per 100pxÂ²
  const densityUnit = cal ? 'cells/cmÂ²' : 'cells/100pxÂ²';
  const density = cal
    ? valid.length / (totalPx / (cal * cal) / 100)  // cells per cmÂ² (100mmÂ²)
    : valid.length / (totalPx / 10000);
  const meanA2  = valid.length ? porePx/valid.length : 0;
  const cvAreas = (() => {
    if (!valid.length) return 0;
    const areas=valid.map(b=>b.area);
    const m=meanA2, v=areas.reduce((s,a)=>s+(a-m)**2,0)/areas.length;
    return Math.sqrt(v)/m;
  })();

  log.push(`\nâ”€â”€ FINGERPRINT â”€â”€`);
  log.push(`Void fraction (2D):   ${(vf2d*100).toFixed(2)}%`);
  log.push(`3D corrected (Ã—${f3d}): ${(vf3d*100).toFixed(2)}%`);
  log.push(`Cell count:           ${valid.length}`);
  log.push(`Cell density:         ${density.toFixed(3)} ${densityUnit}`);
  log.push(`Mean cell area:       ${cal ? toUnit(meanA2).toFixed(2)+' '+unit : Math.round(meanA2)+' pxÂ²'}`);
  log.push(`Cell uniformity (1-CV): ${(Math.max(0,1-cvAreas)*100).toFixed(1)}%`);

  // Quality check vs literature
  if (type==='white'){
    if (vf2d < 0.05) log.push(`\nâš  Very low for white bread (lit 15â€“35%). Check: is lighting creating highlights inside pores? Try raising CLAHE clip or using flatbed scan.`);
    else if (vf2d >= 0.10 && vf2d <= 0.40) log.push(`\nâœ“ Void fraction within expected range for white wheat bread.`);
    else if (vf2d > 0.40) log.push(`\nâš  High â€” may include non-pore regions. Review binary view.`);
    else log.push(`\nâ„¹ Low-end â€” check binary view; may be photography artifacts.`);
  } else {
    if (vf2d < 0.05) log.push(`\nâš  Very low for BSG bread (<5%). Try: more negative offset, lower min cell area, or check image quality.`);
    else if (vf2d >= 0.08 && vf2d <= 0.45) log.push(`\nâœ“ Void fraction within expected range for BSG/dark bread (lit: 10â€“40% for photos, 35â€“47% for flatbed scans).`);
    else if (vf2d > 0.45) log.push(`\nâš  High for BSG bread â€” may include fiber noise. Try less negative offset or increase min cell area.`);
    else log.push(`\nâ„¹ Low-end for BSG â€” adjust peak offset (more negative = more pores detected).`);
    log.push(`  BSG bread has lower porosity than control due to fiber disrupting gluten gas cell structure.`);
    log.push(`  Compare relative values across formulations under identical imaging conditions.`);
  }
  log.push(`\nAlgorithm: ${algoName}`);
  log.push(`Time: ${(performance.now()-t0).toFixed(1)}ms`);

  // â”€â”€ RENDER â”€â”€
  grayToCanvas('c1', enhanced, W, H); show('c1','ph1');
  binToCanvas('c2', closed, W, H);   show('c2','ph2');

  if (valid.length > 0) {
    const areas = valid.map(b=>b.area);
    drawColormap('c3', W, H, valid, Math.min(...areas), Math.max(...areas));
    show('c3','ph3');
  }

  // For BSG: show histogram of raw grayscale (where threshold was computed)
  // For white: show histogram of CLAHE-enhanced (where Otsu was computed)
  buildHistCanvas('c4', type === 'white' ? enhanced : gray, tNorm, peakBin); show('c4','ph4');
  renderHist(valid, totalPx, cal);
  renderFingerprint(valid, totalPx, W, H, cal);

  // Metrics bar
  const fmt2=v=>(v*100).toFixed(1)+'%';
  const setM=(id,v,cls,muId,muTxt)=>{
    const e=document.getElementById(id);e.textContent=v;e.className='mv'+(cls?' '+cls:'');e.closest('.mc').classList.remove('empty');
    if(muId&&muTxt){const mu=e.closest('.mc').querySelector('.mu');if(mu)mu.textContent=muTxt;}
  };
  const vfClass = (type==='white' && vf2d>=0.10&&vf2d<=0.40)?'ok':(type==='bsg' && vf2d>=0.08&&vf2d<=0.45)?'ok': vf2d<0.05?'lo':'';
  setM('m0',fmt2(vf2d),vfClass);
  setM('m1',fmt2(vf3d),'');
  setM('m2',String(valid.length),'ok');
  setM('m3',density.toFixed(2),'',null,densityUnit);
  const meanDisp = cal ? toUnit(meanA2).toFixed(2) : String(Math.round(meanA2));
  setM('m4',meanDisp,'',null,unit+' per pore');
  setM('m5',(Math.max(0,1-cvAreas)*100).toFixed(0)+'%','');
  // Update metric unit labels
  document.getElementById('m3').closest('.mc').querySelector('.mu').textContent = densityUnit;
  document.getElementById('m4').closest('.mc').querySelector('.mu').textContent = unit + ' per pore';

  // Log
  const logEl=document.getElementById('logEl');
  logEl.innerHTML=log.map(l=>
    l.startsWith('âœ“')    ?`<span class="ok">${l}</span>`
    :l.startsWith('âš ')   ?`<span class="warn">${l}</span>`
    :l.startsWith('[LIT]')?`<span class="lit">${l}</span>`
    :l.startsWith('â„¹')   ?`<span style="color:var(--blue)">${l}</span>`
    :l
  ).join('\n');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  10. UI WIRING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const ALGO_TEXT = {
  white: '<strong>Algorithm: Sauvola local adaptive</strong>\nComputes a separate threshold for each pixel based on local mean and standard deviation. Handles uneven lighting from photographic images. Applied on CLAHE-enhanced grayscale.',
  bsg:   '<strong>Algorithm: HisAnalysis peak-mode (Bosakova-Ardenska 2015)</strong>\nThreshold computed on RAW blurred grayscale (no CLAHE) â€” faithful to original method. Peak = dominant crumb color. Negative offset = only darkest pixels (true pores). Validated r=0.93 vs. physicochemical porosity.'
};

// Default parameter sets for each bread type
const DEFAULTS = {
  white: { sg: '1.0', of: '5', minA: '20' },
  bsg:   { sg: '2.0', of: '-8', minA: '10' }
};

function setType(t, btn){
  document.getElementById('wk').dataset.type = t;
  document.querySelectorAll('.tbtn').forEach(b=>b.classList.remove('on'));
  btn.classList.add('on');
  document.getElementById('algoBadge').innerHTML = ALGO_TEXT[t];
  // Auto-switch defaults for bread type
  const d = DEFAULTS[t];
  document.getElementById('sg').value = d.sg;
  document.getElementById('of').value = d.of;
  document.getElementById('minA').value = d.minA;
  syncSliders();
}

function syncSliders(){
  const map=[
    ['sg','sgV','.1f'],['cl','clV','.1f'],['of','ofV','off'],
    ['minA','minAV',''],['maxA','maxAV',''],['f3','f3V','.2f']
  ];
  map.forEach(([id,vid,fmt])=>{
    const v=document.getElementById(id).value;
    let txt;
    if(fmt==='off') txt=(parseInt(v)>=0?'+':'')+v+'%';
    else if(fmt==='.2f') txt=parseFloat(v).toFixed(2);
    else if(fmt==='.1f') txt=parseFloat(v).toFixed(1);
    else txt=v;
    document.getElementById(vid).textContent=txt;
  });
}
function onSliderChange(){syncSliders();if(!document.getElementById('runBtn').disabled)analyze();}
document.querySelectorAll('input[type=range]').forEach(el=>el.addEventListener('input',onSliderChange));

function loadImg(file){
  const r=new FileReader();
  r.onload=ev=>{
    const img=new Image();
    img.onload=()=>{
      const MAX=650; let iw=img.width,ih=img.height;
      if(iw>MAX||ih>MAX){const ratio=Math.min(MAX/iw,MAX/ih);iw=Math.round(iw*ratio);ih=Math.round(ih*ratio);}
      // Reset state for new image
      resetState();
      STATE.imgW = iw; STATE.imgH = ih;
      const wk=document.getElementById('wk');
      wk.width=iw; wk.height=ih;
      if(!wk.dataset.type) wk.dataset.type='white';
      wk.getContext('2d').drawImage(img,0,0,iw,ih);
      const c0=document.getElementById('c0'); c0.width=iw; c0.height=ih;
      c0.getContext('2d').drawImage(img,0,0,iw,ih);
      document.getElementById('ph0').style.display='none';
      document.getElementById('c0wrap').style.display='block';
      ['ph1','ph2','ph3','ph4'].forEach(id=>{document.getElementById(id).style.display='';});
      ['c1','c2','c3','c4'].forEach(id=>{document.getElementById(id).style.display='none';});
      document.getElementById('runBtn').disabled=true;
      document.getElementById('dz').querySelector('p').innerHTML=`<strong style="color:var(--green)">&#10003; ${file.name}</strong><br>${iw}Ã—${ih} px`;
      document.getElementById('logEl').textContent='Image loaded â€” choose calibration mode.';
      // Show the modal
      showUploadModal();
    };
    img.src=ev.target.result;
  };
  r.readAsDataURL(file);
}

document.getElementById('imgIn').addEventListener('change',e=>{if(e.target.files[0])loadImg(e.target.files[0]);});
const dz=document.getElementById('dz');
dz.addEventListener('dragover',e=>{e.preventDefault();dz.classList.add('drag');});
dz.addEventListener('dragleave',()=>dz.classList.remove('drag'));
dz.addEventListener('drop',e=>{e.preventDefault();dz.classList.remove('drag');const f=e.dataTransfer.files[0];if(f&&f.type.startsWith('image/'))loadImg(f);});
document.getElementById('runBtn').addEventListener('click',analyze);

// Ruler mm input: recalculate on change (inside cal modal)
document.getElementById('rulerMm').addEventListener('input', () => {
  if (STATE.calPts.length === 2 && STATE.mode === 'ruler') calcCalibration();
});
// Coin dropdown: recalculate on change (inside cal modal)
document.getElementById('coinSelect').addEventListener('change', () => {
  if (STATE.calPts.length === 2 && STATE.mode === 'coin') calcCalibration();
});

syncSliders();
initOverlayEvents();
initCalModalEvents();
</script>
</body>
</html>
